---
title: "Political Geography"
author: "Alex Nelson"
date: "7/25/2019"
output:
  md_document:
    variant: gfm
    toc: true
    toc_depth: 4
---

```{r setup, include=FALSE}
library(tidyverse)
library(ggplot2)
library(ggthemes)
library(maps)

library(MXM) # for transitiveClosure()
library(zoo)

library(rmarkdown)

knitr::opts_chunk$set(echo = TRUE)
```
```{r, include=FALSE}
source("../R/states.R")
```


# Introduction

The goal is to try to cluster states based on geographic proximity and similar voting tendency. The first thing we do is load the data.

```{r}
load("../data/elections/senate/1976_2018_senate.RData")
senate_data <- x %>%
  filter(stage == "gen") %>%
  mutate(party = ifelse((party == "democrat" | party == "democratic-farmer-labor") & writein == F, "democrat",
                        ifelse(party == "republican" & writein == F, party, "$third")))

load("../data/elections/house/1976_2018_house.RData")
house_data <- x %>%
  filter(stage == "gen") %>%
  mutate(party = ifelse((party == "democrat" | party == "democratic-farmer-labor") & writein == F, "democrat",
                        ifelse(party == "republican" & writein == F, party, "$third")))

load("../data/elections/presidential/state/1976_2016_president.RData")
president_data <- x %>%
  mutate(party = ifelse((party == "democrat" | party == "democratic-farmer-labor") & writein == F, "democrat",
                        ifelse(party == "republican" & writein == F, party, "$third"))) %>%
  group_by(state, year) %>%
  mutate(totalvotes = sum(candidatevotes)) %>%
  ungroup
```

We now need to work our way to produce a triple for each state.

```{r}
house <- house_data %>%
  filter(special == F) %>%
  group_by(state, party, district, year) %>%
  summarize(candidatevotes = sum(candidatevotes),
            totalvotes = totalvotes[[1]]) %>%
  spread(party, candidatevotes, fill = 0) %>%
  select(-`<NA>`) %>%
  mutate(third = `$third`/totalvotes,
         dem = democrat/totalvotes,
         rep = republican/totalvotes)

senate <- senate_data %>%
  filter(special == F) %>%
  group_by(state, year, party, totalvotes) %>%
  summarize(candidatevotes = sum(candidatevotes)) %>%
  ungroup() %>%
  spread(party, candidatevotes, fill = 0) %>%
  select(-`<NA>`) %>%
  mutate(third = `$third`/totalvotes,
         dem = democrat/totalvotes,
         rep = republican/totalvotes)

president <- president_data %>% 
  group_by(state, year, party, totalvotes) %>%
  summarize(candidatevotes = sum(candidatevotes)) %>%
  ungroup() %>%
  spread(party, candidatevotes, fill = 0) %>%
  select(-`<NA>`) %>%
  mutate(third = `$third`/totalvotes,
         dem = democrat/totalvotes,
         rep = republican/totalvotes)
```

We create a vector for a given state representing the `third`, `dem`, `rep` percents ordered in time. Then these vectors are used to compute the correlations between states, pair-wise.

```{r}
state_to_vec <- function(data, state_name) {
  (data %>%
    filter(state == state_name) %>%
    gather("party", "percent", third, dem, rep) %>%
    select(state, year, party, percent) %>%
    arrange(year, party))$percent
}
```

```{r}
states <- factor(sort(unique(president$state)))
state_vecs <- list()
for (state in states) {
  # state_vecs <- append(state_vecs, list(state = state_to_vec(president, state)))
  state_vecs[[as.character(state)]] <- state_to_vec(president, state)
}
```

```{r}
cor_mat <- data.frame(from = c(),
                      to = c(),
                      val = c())
cor_mat_spearman <- data.frame(from = c(),
                      to = c(),
                      val = c())
for (i in 1:50) {
  from <- states[i]
  for (j in (1 + i):51) {
    to <- states[j]
    
    val <- cor(state_vecs[[i]], state_vecs[[j]], method = "spearman")
    cor_mat_spearman <- rbind(cor_mat_spearman, data.frame(from = from,
                                         to = to,
                                         val = val))
    
    val <- cor(state_vecs[[i]], state_vecs[[j]])
    cor_mat <- rbind(cor_mat, data.frame(from = from,
                                         to = to,
                                         val = val))
  }
}
```

```{r, spearman_histogram}
ggplot(cor_mat_spearman, aes(x=val)) + 
  geom_histogram(color="black", fill="white")
```

```{r, pearson_histogram}
ggplot(cor_mat, aes(x=val)) + 
  geom_histogram(color="black", fill="white")
```

## Grouping Pair-wise Correlations

```{r}
mat <- matrix(0, 51, 51)
edges <- filter(cor_mat, val > quantile(cor_mat$val, probs = c(0.9))[1])
for (i in 1:51) {
  relevant_edges <- filter(edges, from == states[i], to %in% neighboring_states[[states[i]]])
  if (nrow(relevant_edges) == 0 & length(neighboring_states[[states[i]]]) > 0 & F) {
    to <- factor((filter(cor_mat, from == states[i], to %in% neighboring_states[[states[i]]]) %>% arrange(-val))$to[1], states)
    mat[i, as.integer(to)] <- 1
    mat[as.integer(to), i] <- 1
  } else {
    for (j in relevant_edges$to) {
      to <- factor(j, states)
      mat[i, as.integer(to)] <- 1
      mat[as.integer(to), i] <- 1
    }
  }
}
rownames(mat) <- states
colnames(mat) <- states

tr_ad <- transitiveClosure(mat)
rownames(tr_ad) <- states
colnames(tr_ad) <- states


for (i in 1:51) {
  if (all(tr_ad[i,] == 0 & length(neighboring_states[[states[i]]]) > 0)) {
    print(i)
    choices <- rbind(filter(cor_mat, from == states[i], to %in% neighboring_states[[states[i]]]),
                     filter(cor_mat, to == states[i], from %in% neighboring_states[[states[i]]]))
    to <- (choices %>% arrange(-val))$to[1]
    print(head((choices %>% arrange(-val))))
    if (to == states[i]) {
      to <- factor((choices %>% arrange(-val))$from[1], states)
    } else {
      to <- factor(to, states)
    }
    tr_ad[i, as.integer(to)] <- 1
    tr_ad[as.integer(to), i] <- 1    
  }
}

tr_ad <- transitiveClosure(tr_ad)
rownames(tr_ad) <- states
colnames(tr_ad) <- states
```

```{r}
ci <- 1
clusters <- data.frame(region = c(),
                       cluster = c())
for (i in 1:51) {
  others <- rownames(as.matrix(Filter(function(x) {x > 0}, tr_ad[i, ])))
  if (length(others) > 0 & !(tolower(as.character(states[i])) %in% clusters$region)) {
    for(other in sort(append(others, as.character(states[i])))) {
      clusters <- rbind(clusters, data.frame(region = c(tolower(as.character(other))),
                                             cluster = c(ci)))
    }
    ci <- ci + 1
  }
}
clusters$cluster <- factor(clusters$cluster)
```

```{r, clustered_map}
party_colors <- c("#008FD5", "#ff7400","#77AB43",
                  "#008FD5", "#77AB43", "#FF2700",
                  "#008FD5", # "#FF2700", 
                  "#ff7400", # "#FF2700", 
                  "#77AB43",
                   "#FF2700", "#FF2700", "#77AB43")
us_states <- map_data("state")
clustered_states <- us_states %>%
  inner_join(clusters, by = "region")

p <- ggplot(data = clustered_states,
            mapping = aes(x = long, y = lat, 
                          fill = cluster, group = group))
p + geom_polygon(color = "gray90", size = 0.1) + 
  coord_fixed(1.3) +
  scale_fill_manual(values = party_colors) +
  guides(fill = FALSE) + # no legend!
  labs(caption="http://political-arithmetic.blogspot.com",
       title= "State Clusters", 
       subtitle="Clustering states based on Presidential voting behavior 1976-2016")
p
```

